<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>{{ page.title }} | {{ site.title }}</title>
<link rel="stylesheet" href="{{ '/assets/css/custom.css' | relative_url }}">
<link rel="icon" href="{{ '/assets/images/favicon.png' | relative_url }}">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<!-- Noise overlay -->
<div class="noise-overlay"></div>

<!-- Digital grid (static, subtle) -->
<div class="digital-grid"></div>

<!-- Grid highlight that only shows on hover -->
<div class="grid-highlight"></div>

<!-- Subtle X and Y axis scanlines -->
<div class="axis-scanline-x"></div>
<div class="axis-scanline-y"></div>

<!-- Boot Sequence - ONLY ON HOMEPAGE -->
{% if page.url == "/" %}
<div id="boot-sequence" class="boot">
<pre id="boot-text"></pre>
</div>
{% endif %}

<!-- Main Content -->
<div id="main-content" {% unless page.url == "/" %}style="display:block;"{% else %}style="display:none;"{% endunless %}>
<header>
<h1 class="title">{{ site.title }}</h1>
<p class="desc">{{ site.description }}</p>
{% unless page.url == "/" %}
<nav>
<a href="{{ '/' | relative_url }}" class="home-link">← Back to Lab</a>
</nav>
{% endunless %}
</header>
<main>
{{ content }}
</main>
</div>

<!-- Glowing Cursor -->
<div class="cursor-light"></div>

<!-- Consolidated Scripts -->
<script>
(function() {
  'use strict';
  
  // ========== CURSOR & GRID ANIMATION ==========
  const cursor = document.querySelector(".cursor-light");
  const gridHighlight = document.querySelector(".grid-highlight");
  const axisX = document.querySelector(".axis-scanline-x");
  const axisY = document.querySelector(".axis-scanline-y");
  
  let x = 0, y = 0, targetX = 0, targetY = 0;
  let isMoving = false;
  let moveTimeout;

  document.addEventListener("mousemove", e => {
    targetX = e.clientX;
    targetY = e.clientY;
    
    // Update axis scanlines immediately
    if (axisX) axisX.style.top = `${e.clientY}px`;
    if (axisY) axisY.style.left = `${e.clientX}px`;
    
    // Update grid highlight immediately (only shows on hover)
    if (gridHighlight) {
      gridHighlight.style.left = `${e.clientX}px`;
      gridHighlight.style.top = `${e.clientY}px`;
    }
    
    // Track movement for grid visibility
    isMoving = true;
    clearTimeout(moveTimeout);
    moveTimeout = setTimeout(() => {
      isMoving = false;
    }, 100);
  });

  function animateCursor() {
    x += (targetX - x) * 0.15;
    y += (targetY - y) * 0.15;
    if (cursor) {
      cursor.style.left = `${x}px`;
      cursor.style.top = `${y}px`;
    }
    requestAnimationFrame(animateCursor);
  }
  animateCursor();

  // ========== BOOT SEQUENCE ==========
  {% if page.layout == "default" and page.url == "/" %}
  const bootLines = [">Great to see you. I'm 0xm0t0k0 aka 0xth00rf1nn aka c1nn4m0nr0ls"];
  const bootText = document.getElementById("boot-text");
  const bootScreen = document.getElementById("boot-sequence");
  const mainContent = document.getElementById("main-content");
  
  if (bootText && bootScreen && mainContent) {
    let line = 0, char = 0;
    
    function typeBootLine() {
      if (line < bootLines.length) {
        if (char < bootLines[line].length) {
          bootText.textContent += bootLines[line].charAt(char);
          char++;
          setTimeout(typeBootLine, 30);
        } else {
          bootText.textContent += "\n";
          line++;
          char = 0;
          setTimeout(typeBootLine, 400);
        }
      } else {
        setTimeout(() => {
          bootScreen.style.opacity = "0";
          setTimeout(() => {
            bootScreen.style.display = "none";
            mainContent.style.display = "block";
          }, 1000);
        }, 600);
      }
    }
    
    typeBootLine();
  }
  {% endif %}
})();
</script>

<!-- Multi-Stage Encryption Puzzle Script -->
<script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', () => {
    const unlockBtn = document.getElementById('unlockBtn');
    const decryptInput = document.getElementById('decryptInput');
    const errorMessage = document.getElementById('errorMessage');
    const puzzle = document.getElementById('portfolioPuzzle');
    const content = document.getElementById('portfolioContent');
    const currentStageEl = document.getElementById('currentStage');
    const progressFill = document.getElementById('progressFill');
    
    if (!unlockBtn) return;
    
    // Stage configuration
    let currentStage = 1;
    const stages = {
      1: { answer: '0xm0t0k0', nextStage: 2, progress: 33 },
      2: { answer: '0xth00rf1nn', nextStage: 3, progress: 66 },
      3: { answer: '4cc3ss_gr4nt3d_w3lc0m3_!', nextStage: 'unlock', progress: 100 }
    };
    
    // Check saved progress
    const savedStage = sessionStorage.getItem('puzzleStage');
    if (savedStage) {
      currentStage = parseInt(savedStage);
      loadStage(currentStage);
    }
    
    function loadStage(stageNum) {
      // Hide all stages
      for (let i = 1; i <= 3; i++) {
        const stage = document.getElementById(`stage${i}`);
        if (stage) stage.style.display = 'none';
      }
      
      // Show current stage
      const currentStageDiv = document.getElementById(`stage${stageNum}`);
      if (currentStageDiv) currentStageDiv.style.display = 'block';
      
      // Update UI
      if (currentStageEl) currentStageEl.textContent = stageNum;
      decryptInput.value = '';
      decryptInput.focus();
      
      // Update progress bar
      const previousProgress = stageNum === 1 ? 0 : stages[stageNum - 1].progress;
      if (progressFill) progressFill.style.width = previousProgress + '%';
    }
    
    function unlockPortfolio() {
      puzzle.style.display = 'none';
      content.style.display = 'block';
      sessionStorage.setItem('portfolioUnlocked', 'true');
      sessionStorage.removeItem('puzzleStage');
      
      // Track completion
      if (window.trackPuzzleCompletion) {
        window.trackPuzzleCompletion();
      }
    }
    
    // Terminal typing effect
    function typeMessage(element, message, color, callback) {
      element.style.color = color;
      element.textContent = '';
      let i = 0;
      const interval = setInterval(() => {
        if (i < message.length) {
          element.textContent += message.charAt(i);
          i++;
        } else {
          clearInterval(interval);
          if (callback) callback();
        }
      }, 30);
    }
    
    function checkAnswer() {
      const userAnswer = decryptInput.value.trim().toLowerCase();
      const correctAnswer = stages[currentStage].answer.toLowerCase();
      
      if (userAnswer === correctAnswer) {
        typeMessage(errorMessage, `✓ STAGE ${currentStage} COMPLETE - AUTHORIZATION GRANTED`, '#39ff14', () => {
          const stageDiv = document.getElementById(`stage${currentStage}`);
          if (stageDiv) stageDiv.classList.add('stage-complete');
          
          if (progressFill) progressFill.style.width = stages[currentStage].progress + '%';
          
          setTimeout(() => {
            if (stages[currentStage].nextStage === 'unlock') {
              typeMessage(errorMessage, '✓ ALL STAGES COMPLETE - INITIATING ACCESS...', '#39ff14', () => {
                setTimeout(unlockPortfolio, 1000);
              });
            } else {
              currentStage = stages[currentStage].nextStage;
              sessionStorage.setItem('puzzleStage', currentStage);
              loadStage(currentStage);
              errorMessage.textContent = '';
            }
          }, 1500);
        });
      } else {
        typeMessage(errorMessage, '✗ ACCESS DENIED - INVALID CREDENTIALS', '#ff3333');
        decryptInput.value = '';
        decryptInput.classList.add('error');
        
        puzzle.style.animation = 'glitchShake 0.3s ease';
        setTimeout(() => {
          decryptInput.classList.remove('error');
          puzzle.style.animation = '';
          setTimeout(() => errorMessage.textContent = '', 2000);
        }, 500);
      }
    }
    
    unlockBtn.addEventListener('click', checkAnswer);
    decryptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') checkAnswer();
    });
    
    // Typing visual effect
    decryptInput.addEventListener('input', () => {
      decryptInput.style.textShadow = '0 0 10px #39ff14';
      setTimeout(() => {
        decryptInput.style.textShadow = '0 0 5px #39ff14';
      }, 50);
    });
    
    // Hint system (click title 5 times)
    let hintClicks = 0;
    const puzzleTitle = document.querySelector('.puzzle-title');
    
    if (puzzleTitle) {
      puzzleTitle.addEventListener('click', () => {
        hintClicks++;
        if (hintClicks === 5) {
          const hints = {
            1: 'HINT: Binary to text converter required',
            2: 'HINT: Hexadecimal to ASCII decoder needed',
            3: 'HINT: Base64 decoder - final authentication key'
          };
          typeMessage(errorMessage, hints[currentStage], '#39ff14');
          setTimeout(() => {
            if (errorMessage.textContent.includes('HINT:')) {
              errorMessage.textContent = '';
            }
          }, 5000);
          hintClicks = 0;
        }
      });
    }
  });
})();
</script>

<!-- Portfolio Script -->
<script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', () => {
    const portfolioItems = document.querySelectorAll('.portfolio-item');
    const loadMoreBtn = document.getElementById('loadMore');
    const shownCountEl = document.getElementById('shownCount');
    const totalCountEl = document.getElementById('totalCount');
    const filterBtns = document.querySelectorAll('.filter-btn');
    
    if (!loadMoreBtn || !portfolioItems.length) return;
    
    let itemsPerLoad = 12;
    let currentItems = itemsPerLoad;
    
    if (totalCountEl) totalCountEl.textContent = portfolioItems.length;
    
    function updateVisibility() {
      let visibleCount = 0;
      portfolioItems.forEach((item, index) => {
        if (!item.classList.contains('hidden-filter')) {
          if (visibleCount < currentItems) {
            item.classList.remove('hidden-load');
            item.style.animationDelay = `${(visibleCount % itemsPerLoad) * 0.05}s`;
            visibleCount++;
          } else {
            item.classList.add('hidden-load');
          }
        }
      });
      
      if (shownCountEl) shownCountEl.textContent = visibleCount;
      
      const hiddenFilterCount = document.querySelectorAll('.hidden-filter').length;
      if (visibleCount >= portfolioItems.length - hiddenFilterCount) {
        loadMoreBtn.classList.add('hidden');
      } else {
        loadMoreBtn.classList.remove('hidden');
      }
    }
    
    updateVisibility();
    
    loadMoreBtn.addEventListener('click', () => {
      currentItems += itemsPerLoad;
      updateVisibility();
    });
    
    // Lazy loading with Intersection Observer
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
          }
        }
      });
    });
    
    document.querySelectorAll('.portfolio-img.lazy').forEach(img => {
      imageObserver.observe(img);
    });
    
    // Filter functionality
    filterBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const filter = btn.getAttribute('data-filter');
        currentItems = itemsPerLoad;
        
        portfolioItems.forEach(item => {
          if (filter === 'all' || item.getAttribute('data-category') === filter) {
            item.classList.remove('hidden-filter');
          } else {
            item.classList.add('hidden-filter');
          }
        });
        
        updateVisibility();
      });
    });
  });
})();
</script>

<!-- Enhanced Interactive Terminal Navigation Script -->
<script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', () => {
    const navInput = document.getElementById('navInput');
    const navOutput = document.getElementById('navOutput');
    
    if (!navInput || !navOutput) return;
    
    let commandHistory = [];
    let historyIndex = -1;
    
    const commands = {
      help: {
        desc: 'Show available commands',
        output: `<div class="welcome">╔═══════════════════════════════════════╗
║         AVAILABLE COMMANDS            ║
╚═══════════════════════════════════════╝</div>
<span class="info">Navigation:</span>
  ls                - list all sections
  cat about.txt     - view about page
  cd logs/          - scroll to blog posts
  ./portfolio.sh    - access portfolio (requires key)
  cat manifesto/*   - view texts & papers

<span class="info">System:</span>
  help              - show this message
  clear             - clear terminal output
  whoami            - show current user
  history           - show command history
  cat README.md     - read documentation

<span class="info">Tip:</span> Use ↑/↓ arrow keys to navigate command history`
      },
      
      ls: {
        desc: 'List available pages',
        output: `drwxr-xr-x  2 visitor visitor 4096 Nov 07 2025 <a href="/about">about.txt</a>
drwxr-xr-x  3 visitor visitor 4096 Nov 07 2025 logs/
-rwxr-xr-x  1 visitor visitor 2048 Nov 07 2025 portfolio.sh
drwxr-xr-x  2 visitor visitor 4096 Nov 07 2025 manifesto/
-rw-r--r--  1 visitor visitor  512 Nov 07 2025 README.md`
      },
      
      'cat about.txt': {
        desc: 'Open about page',
        action: () => {
          setTimeout(() => window.location.href = '/about', 500);
          return 'Opening about.txt...\n<span class="typing-indicator">█</span>';
        }
      },
      
      'cd logs/': {
        desc: 'Navigate to logs',
        action: () => {
          const logsEl = document.getElementById('logs');
          if (logsEl) logsEl.scrollIntoView({ behavior: 'smooth' });
          return '✓ Changed directory to logs/';
        }
      },
      
      'cd logs': {
        desc: 'Navigate to logs',
        action: () => {
          const logsEl = document.getElementById('logs');
          if (logsEl) logsEl.scrollIntoView({ behavior: 'smooth' });
          return '✓ Changed directory to logs/';
        }
      },
      
      './portfolio.sh': {
        desc: 'Access portfolio',
        action: () => {
          const portfolioEl = document.getElementById('portfolio');
          if (portfolioEl) portfolioEl.scrollIntoView({ behavior: 'smooth' });
          return `Executing portfolio.sh...
<span class="info">▶ Initializing decryption module...</span>
<span class="info">▶ Portfolio access requires authentication</span>`;
        }
      },
      
      'cat manifesto/*': {
        desc: 'View texts & papers',
        action: () => {
          const textsEl = document.getElementById('texts');
          if (textsEl) textsEl.scrollIntoView({ behavior: 'smooth' });
          return `Reading manifesto files...
<span class="info">▶ Loading: recursive-deconstruction.txt</span>
`;
        }
      },
      
      clear: {
        desc: 'Clear terminal',
        action: () => {
          navOutput.innerHTML = '';
          return '';
        }
      },
      
      whoami: {
        desc: 'Show current user',
        output: () => {
          const userId = localStorage.getItem('cryptolab_user_id')?.substr(0, 16) || 'anonymous';
          return `visitor@cryptolab
<span class="info">User ID:</span> ${userId}...
<span class="info">Privileges:</span> guest
<span class="info">Access Level:</span> public`;
        }
      },
      
      history: {
        desc: 'Show command history',
        action: () => {
          if (commandHistory.length === 0) {
            return '<span class="info">No command history yet</span>';
          }
          return commandHistory.map((cmd, i) => `  ${i + 1}  ${cmd}`).join('\n');
        }
      },
      
      'cat README.md': {
        desc: 'Read documentation',
        output: `<div class="welcome">╔═══════════════════════════════════════╗
║      CRYPTOLAB TERMINAL v1.0          ║
╚═══════════════════════════════════════╝</div>

<span class="info">Welcome to 0xm0t0k0's Cryptography & CS Lab</span>

This is an interactive terminal interface for navigating
the site. Type commands to explore different sections.

<span class="info">Getting Started:</span>
  • Type 'help' to see all available commands
  • Use 'ls' to list all pages
  • Navigate using 'cd' or 'cat' commands
  • Press ↑/↓ to cycle through command history

<span class="info">Pro Tip:</span> Try 'cat about.txt' to learn more about me!`
      }
    };
    
    function typeOutput(text, className = 'success') {
      const line = document.createElement('div');
      line.className = `cmd-line ${className}`;
      line.innerHTML = text;
      navOutput.appendChild(line);
      navOutput.scrollTop = navOutput.scrollHeight;
    }
    
    function executeCommand(cmd) {
      if (cmd && cmd !== commandHistory[commandHistory.length - 1]) {
        commandHistory.push(cmd);
      }
      historyIndex = commandHistory.length;
      
      typeOutput(`visitor@cryptolab:~$ ${cmd}`, 'info');
      
      const command = commands[cmd];
      if (command) {
        const result = command.action 
          ? command.action() 
          : (typeof command.output === 'function' ? command.output() : command.output);
        
        if (result) {
          setTimeout(() => typeOutput(result), 100);
        }
      } else if (cmd.trim()) {
        setTimeout(() => {
          typeOutput(`bash: ${cmd}: command not found
<span class="info">Type 'help' to see available commands</span>`, 'error');
        }, 100);
      }
    }
    
    navInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const cmd = navInput.value.trim();
        executeCommand(cmd);
        navInput.value = '';
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          navInput.value = commandHistory[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          navInput.value = commandHistory[historyIndex];
        } else {
          historyIndex = commandHistory.length;
          navInput.value = '';
        }
      } else if (e.key === 'Tab') {
        e.preventDefault();
        const input = navInput.value.trim();
        const matches = Object.keys(commands).filter(cmd => cmd.startsWith(input));
        if (matches.length === 1) {
          navInput.value = matches[0];
        } else if (matches.length > 1) {
          typeOutput(`Possible commands: ${matches.join(', ')}`, 'info');
        }
      }
    });
    
    const terminalNav = document.querySelector('.terminal-nav');
    if (terminalNav) {
      terminalNav.addEventListener('click', () => navInput.focus());
    }
    
    setTimeout(() => {
      typeOutput(`<div class="welcome">Welcome to CryptoLab Terminal
Type '<span style="color: #00ffff;">help</span>' to see available commands or '<span style="color: #00ffff;">cat README.md</span>' to get started</div>`);
    }, 500);
    
    navInput.focus();
  });
})();
</script>

<!-- User Tracking & Persistence Script -->
<script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', () => {
    function getUserId() {
      let userId = localStorage.getItem('cryptolab_user_id');
      if (!userId) {
        userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('cryptolab_user_id', userId);
      }
      return userId;
    }
    
    function trackPuzzleCompletion(userId) {
      const completions = JSON.parse(localStorage.getItem('puzzle_completions') || '[]');
      completions.push({
        userId: userId,
        timestamp: new Date().toISOString(),
        stages: [1, 2, 3]
      });
      localStorage.setItem('puzzle_completions', JSON.stringify(completions));
    }
    
    function recentlyCompleted(userId) {
      const completions = JSON.parse(localStorage.getItem('puzzle_completions') || '[]');
      const userCompletions = completions.filter(c => c.userId === userId);
      
      if (userCompletions.length === 0) return false;
      
      const lastCompletion = new Date(userCompletions[userCompletions.length - 1].timestamp);
      const now = new Date();
      const hoursSince = (now - lastCompletion) / (1000 * 60 * 60);
      
      return hoursSince < 24;
    }
    
    function showUserStats(userId) {
      const completions = JSON.parse(localStorage.getItem('puzzle_completions') || '[]');
      const userCompletions = completions.filter(c => c.userId === userId);
      
      if (userCompletions.length > 1) {
        const statsDiv = document.createElement('div');
        statsDiv.className = 'user-stats';
        statsDiv.innerHTML = `
          <p>Welcome back, ${userId.substr(0, 12)}...</p>
          <p>Puzzle completions: ${userCompletions.length}</p>
        `;
        const puzzleEl = document.querySelector('.encryption-puzzle');
        if (puzzleEl) puzzleEl.prepend(statsDiv);
      }
    }
    
    const userId = getUserId();
    
    // Make trackPuzzleCompletion available globally
    window.trackPuzzleCompletion = function() {
      trackPuzzleCompletion(userId);
    };
    
    if (document.getElementById('portfolioPuzzle')) {
      showUserStats(userId);
    }
    
    console.log(`[CryptoLab] User ID: ${userId}`);
    console.log(`[CryptoLab] Recent completion: ${recentlyCompleted(userId)}`);
  });
})();
</script>

<!-- Image Lightbox Modal -->
<div id="imageLightbox" class="lightbox">
  <div class="lightbox-backdrop"></div>
  <div class="lightbox-content">
    <button class="lightbox-close" aria-label="Close">&times;</button>
    <button class="lightbox-prev" aria-label="Previous">‹</button>
    <button class="lightbox-next" aria-label="Next">›</button>
    <div class="lightbox-image-container">
      <img id="lightboxImage" src="" alt="" class="lightbox-image">
      <div class="lightbox-info">
        <h3 id="lightboxTitle"></h3>
        <p id="lightboxYear"></p>
      </div>
    </div>
    <div class="lightbox-counter">
      <span id="lightboxCounter"></span>
    </div>
  </div>
</div>

<!-- Image Lightbox Script -->
<script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', () => {
    const lightbox = document.getElementById('imageLightbox');
    const lightboxImage = document.getElementById('lightboxImage');
    const lightboxTitle = document.getElementById('lightboxTitle');
    const lightboxYear = document.getElementById('lightboxYear');
    const lightboxCounter = document.getElementById('lightboxCounter');
    const closeBtn = document.querySelector('.lightbox-close');
    const prevBtn = document.querySelector('.lightbox-prev');
    const nextBtn = document.querySelector('.lightbox-next');
    
    if (!lightbox) return;
    
    let currentIndex = 0;
    let images = [];
    
    // Initialize portfolio images
    function initializeLightbox() {
      const portfolioItems = document.querySelectorAll('.portfolio-item:not(.hidden-filter):not(.hidden-load)');
      
      images = Array.from(portfolioItems).map(item => {
        const img = item.querySelector('.portfolio-img');
        const title = item.querySelector('.overlay-content h4')?.textContent || 'Untitled';
        const year = item.querySelector('.overlay-content .year')?.textContent || '';
        
        return {
          src: img.dataset.src || img.src,
          title: title,
          year: year,
          element: item
        };
      });
      
      // Add click handlers to portfolio images
      portfolioItems.forEach((item, index) => {
        const imgWrapper = item.querySelector('.portfolio-img-wrapper');
        if (imgWrapper) {
          imgWrapper.style.cursor = 'pointer';
          imgWrapper.addEventListener('click', (e) => {
            e.preventDefault();
            openLightbox(index);
          });
        }
      });
    }
    
    // Open lightbox
    function openLightbox(index) {
      if (images.length === 0) return;
      
      currentIndex = index;
      updateLightbox();
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Update navigation button visibility
      if (images.length <= 1) {
        prevBtn.classList.add('hidden');
        nextBtn.classList.add('hidden');
      } else {
        prevBtn.classList.remove('hidden');
        nextBtn.classList.remove('hidden');
      }
    }
    
    // Close lightbox
    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    // Update lightbox content
    function updateLightbox() {
      const currentImage = images[currentIndex];
      
      lightboxImage.classList.add('loading');
      lightboxImage.src = currentImage.src;
      lightboxImage.alt = currentImage.title;
      
      lightboxImage.onload = () => {
        lightboxImage.classList.remove('loading');
      };
      
      
    }
    
    // Navigate to previous image
    function showPrevious() {
      currentIndex = (currentIndex - 1 + images.length) % images.length;
      updateLightbox();
    }
    
    // Navigate to next image
    function showNext() {
      currentIndex = (currentIndex + 1) % images.length;
      updateLightbox();
    }
    
    // Event listeners
    closeBtn.addEventListener('click', closeLightbox);
    prevBtn.addEventListener('click', showPrevious);
    nextBtn.addEventListener('click', showNext);
    
    // Close on backdrop click
    lightbox.querySelector('.lightbox-backdrop').addEventListener('click', closeLightbox);
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (!lightbox.classList.contains('active')) return;
      
      switch(e.key) {
        case 'Escape':
          closeLightbox();
          break;
        case 'ArrowLeft':
          showPrevious();
          break;
        case 'ArrowRight':
          showNext();
          break;
      }
    });
    
    // Prevent closing when clicking on image
    lightboxImage.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Re-initialize when filters change
    const filterBtns = document.querySelectorAll('.filter-btn');
    filterBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        setTimeout(initializeLightbox, 100);
      });
    });
    
    // Re-initialize when load more is clicked
    const loadMoreBtn = document.getElementById('loadMore');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', () => {
        setTimeout(initializeLightbox, 100);
      });
    }
    
    // Initialize on page load
    initializeLightbox();
  });
})();
</script>

</body>
</html>